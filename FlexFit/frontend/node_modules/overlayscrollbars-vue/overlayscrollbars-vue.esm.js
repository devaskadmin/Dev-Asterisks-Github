import { shallowRef as w, watch as b, unref as u, onUnmounted as _, defineComponent as A, toRefs as D, ref as h, watchPostEffect as j, openBlock as S, createBlock as z, resolveDynamicComponent as B, withCtx as q, renderSlot as C, createElementBlock as F } from "vue";
import { OverlayScrollbars as y } from "overlayscrollbars";
const g = () => {
  if (typeof window > "u") {
    const o = () => {
    };
    return [o, o];
  }
  let a, t;
  const n = window, l = typeof n.requestIdleCallback == "function", s = n.requestAnimationFrame, r = n.cancelAnimationFrame, f = l ? n.requestIdleCallback : s, p = l ? n.cancelIdleCallback : r, e = () => {
    p(a), r(t);
  };
  return [
    (o, m) => {
      e(), a = f(
        l ? () => {
          e(), t = s(o);
        } : o,
        typeof m == "object" ? m : { timeout: 2233 }
      );
    },
    e
  ];
}, x = (a) => {
  let t = null, n, l, s;
  const r = w(a || {}), [f, p] = g();
  return b(
    () => {
      var e;
      return u((e = r.value) == null ? void 0 : e.defer);
    },
    (e) => {
      s = e;
    },
    { deep: !0, immediate: !0 }
  ), b(
    () => {
      var e;
      return u((e = r.value) == null ? void 0 : e.options);
    },
    (e) => {
      n = e, y.valid(t) && t.options(n || {}, !0);
    },
    { deep: !0, immediate: !0 }
  ), b(
    () => {
      var e;
      return u((e = r.value) == null ? void 0 : e.events);
    },
    (e) => {
      l = e, y.valid(t) && t.on(
        /* c8 ignore next */
        l || {},
        !0
      );
    },
    { deep: !0, immediate: !0 }
  ), _(() => {
    p(), t == null || t.destroy();
  }), [
    (e) => {
      if (y.valid(t))
        return t;
      const o = () => t = y(e, n || {}, l || {});
      s ? f(o, s) : o();
    },
    () => t
  ];
}, P = /* @__PURE__ */ A({
  __name: "OverlayScrollbarsComponent",
  props: {
    element: {
      type: [String, Object],
      default: "div"
    },
    options: { type: Object },
    events: { type: Object },
    defer: { type: [Boolean, Object] }
  },
  emits: ["osInitialized", "osUpdated", "osDestroyed", "osScroll"],
  setup(a, { expose: t, emit: n }) {
    const l = a, s = {
      initialized: "osInitialized",
      updated: "osUpdated",
      destroyed: "osDestroyed",
      scroll: "osScroll"
    }, { element: r, options: f, events: p, defer: e } = D(l), o = w(null), m = w(null), I = h(), [E, O] = x({ options: f, events: I, defer: e });
    return t({
      osInstance: O,
      getElement: () => o.value
    }), j((c) => {
      const { value: i } = o, { value: v } = m;
      i && (E(
        r.value === "body" ? {
          target: i,
          cancel: {
            body: null
          }
        } : {
          target: i,
          elements: {
            viewport: v,
            content: v
          }
        }
      ), c(() => {
        var d;
        return (d = O()) == null ? void 0 : d.destroy();
      }));
    }), b(
      () => u(p),
      (c) => {
        const i = c || {};
        I.value = Object.keys(s).reduce((v, d) => {
          const k = i[d];
          return v[d] = [
            (...R) => n(
              s[d],
              ...R
            ),
            ...(Array.isArray(k) ? k : [k]).filter(Boolean)
          ], v;
        }, {});
      },
      { deep: !0, immediate: !0 }
    ), (c, i) => (S(), z(B(u(r)), {
      "data-overlayscrollbars-initialize": "",
      ref_key: "elementRef",
      ref: o
    }, {
      default: q(() => [
        u(r) === "body" ? C(c.$slots, "default", { key: 0 }) : (S(), F("div", {
          key: 1,
          "data-overlayscrollbars-contents": "",
          ref_key: "slotRef",
          ref: m
        }, [
          C(c.$slots, "default")
        ], 512))
      ]),
      _: 3
    }, 512));
  }
});
export {
  P as OverlayScrollbarsComponent,
  x as useOverlayScrollbars
};
//# sourceMappingURL=overlayscrollbars-vue.esm.js.map
